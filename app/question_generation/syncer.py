"""Phase 10 â€” DB Sync.

Writes final validated items to the database as serveable inventory.
Stores QTI XML, pipeline_meta, and all validator reports.
This phase is MANDATORY and BLOCKING (spec section 8, Phase 10).

Reuses the sync infrastructure from app/sync/.
"""

from __future__ import annotations

import logging
from typing import Any

from app.question_generation.models import (
    GeneratedItem,
    PhaseResult,
    PipelineMeta,
)
from app.sync.config import DBConfig, SyncEnvironment
from app.sync.db_client import DBClient
from app.sync.models import (
    AtomRelevance,
    DifficultyLevel,
    QuestionAtomRow,
    QuestionRow,
    QuestionSetRow,
    QuestionSource,
    SyncPayload,
)

logger = logging.getLogger(__name__)

# Mapping from pipeline difficulty to DB difficulty enum
_DIFFICULTY_MAP: dict[str, DifficultyLevel] = {
    "easy": DifficultyLevel.LOW,
    "medium": DifficultyLevel.MEDIUM,
    "hard": DifficultyLevel.HIGH,
}


class QuestionSyncer:
    """Syncs generated questions to the database (Phase 10).

    Transforms GeneratedItem objects into DB-compatible rows
    and upserts them using the shared DBClient.
    """

    def __init__(
        self,
        environment: SyncEnvironment = "local",
    ) -> None:
        """Initialize the syncer.

        Args:
            environment: Target database environment.
        """
        self._environment = environment

    def sync(
        self,
        items: list[GeneratedItem],
        atom_id: str,
        dry_run: bool = False,
    ) -> PhaseResult:
        """Sync final items to the database.

        Args:
            items: Validated items to sync.
            atom_id: Atom that owns these items.
            dry_run: If True, rolls back instead of committing.

        Returns:
            PhaseResult with sync report.
        """
        logger.info(
            "Phase 10: Syncing %d items for atom %s (dry_run=%s)",
            len(items), atom_id, dry_run,
        )

        if not items:
            return PhaseResult(
                phase_name="db_sync",
                success=False,
                errors=["No items to sync"],
            )

        try:
            payload = self._build_payload(items, atom_id)
            results = self._execute_sync(payload, dry_run)

            logger.info("Sync results: %s", results)
            return PhaseResult(
                phase_name="db_sync",
                success=True,
                data={"sync_report": results, "dry_run": dry_run},
            )

        except Exception as exc:
            logger.error("DB sync failed: %s", exc)
            return PhaseResult(
                phase_name="db_sync",
                success=False,
                errors=[f"DB sync failed: {exc}"],
            )

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _build_payload(
        self,
        items: list[GeneratedItem],
        atom_id: str,
    ) -> SyncPayload:
        """Transform generated items into a SyncPayload.

        Creates the question_set record, sets question_set_id on each
        question, and builds question-atom links.

        Args:
            items: Final validated items.
            atom_id: Atom ID for question-atom links.

        Returns:
            SyncPayload ready for DB upsert.
        """
        question_set_id = f"qs-{atom_id}"
        question_set = _build_question_set_row(
            question_set_id, atom_id, items,
        )

        questions: list[QuestionRow] = []
        question_atoms: list[QuestionAtomRow] = []

        for item in items:
            question_row = self._item_to_question_row(
                item, question_set_id,
            )
            questions.append(question_row)

            question_atoms.append(
                QuestionAtomRow(
                    question_id=item.item_id,
                    atom_id=atom_id,
                    relevance=AtomRelevance.PRIMARY,
                    reasoning="Generated by atom question pipeline",
                ),
            )

        return SyncPayload(
            question_sets=[question_set],
            questions=questions,
            question_atoms=question_atoms,
        )

    def _item_to_question_row(
        self,
        item: GeneratedItem,
        question_set_id: str,
    ) -> QuestionRow:
        """Convert a GeneratedItem to a QuestionRow.

        Args:
            item: The generated item.
            question_set_id: ID of the parent question set.

        Returns:
            DB-compatible QuestionRow.
        """
        meta = item.pipeline_meta
        diff_level = _map_difficulty(meta) if meta else DifficultyLevel.MEDIUM

        return QuestionRow(
            id=item.item_id,
            source=QuestionSource.QUESTION_SET,
            qti_xml=item.qti_xml,
            difficulty_level=diff_level,
            question_set_id=question_set_id,
        )

    def _execute_sync(
        self,
        payload: SyncPayload,
        dry_run: bool,
    ) -> dict[str, Any]:
        """Execute the DB sync operation.

        Args:
            payload: Data to sync.
            dry_run: Whether to rollback after execution.

        Returns:
            Dict with row counts per table.
        """
        config = DBConfig.for_environment(self._environment)
        client = DBClient(config)
        return client.sync_all(payload, dry_run=dry_run)


def _map_difficulty(meta: PipelineMeta) -> DifficultyLevel:
    """Map pipeline difficulty to DB difficulty enum.

    Args:
        meta: Pipeline metadata with difficulty_level.

    Returns:
        DB-compatible DifficultyLevel.
    """
    return _DIFFICULTY_MAP.get(
        meta.difficulty_level.value,
        DifficultyLevel.MEDIUM,
    )


def _build_question_set_row(
    question_set_id: str,
    atom_id: str,
    items: list[GeneratedItem],
) -> QuestionSetRow:
    """Build a QuestionSetRow with per-difficulty counts.

    Args:
        question_set_id: ID for the question set (qs-{atom_id}).
        atom_id: Atom that owns this question set.
        items: Final validated items.

    Returns:
        QuestionSetRow populated with difficulty counts.
    """
    from datetime import datetime, timezone

    counts = {"low": 0, "medium": 0, "high": 0}
    for item in items:
        if item.pipeline_meta:
            db_diff = _map_difficulty(item.pipeline_meta)
            counts[db_diff.value] = counts.get(db_diff.value, 0) + 1

    return QuestionSetRow(
        id=question_set_id,
        atom_id=atom_id,
        low_count=counts["low"],
        medium_count=counts["medium"],
        high_count=counts["high"],
        generated_at=datetime.now(timezone.utc).isoformat(),
    )
